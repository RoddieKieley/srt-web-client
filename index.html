<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser-arcade-physics.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@5.0.0/bundles/stomp.umd.min.js"></script>
    <script src="javascript/rhea.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/protobufjs@6.10.2/dist/protobuf.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/uuidv4.min.js"></script>
</head>
<body>

  <script>
    // identify us during the session
    //const myuuid = uuidv4();
    const myuuid = '3ef0eb3a-6b33-4f5e-924a-79b3bd1e72d8';

    const players = {};

    const resolution_width = 800;
    const resolution_height = 600;

    var config = {
      type: Phaser.AUTO,
      width: resolution_width,
      height: resolution_height,
      physics: {
          default: 'arcade',
          arcade: {
              debug: true
          }
        },
      scene: {
        create: create,
        preload: preload,
        update: update
      }
    };
    
    var graphics;

    var game = new Phaser.Game(config);

    var player_group;

    function create () {
      player_group = this.physics.add.group({
          collideWorldBounds: true
      });
    }
    
    function preload () {
      //this.load.setBaseURL('http://labs.phaser.io');
    
      this.load.image('spacepod', 'images/spacepod.png');
    }
    
    function update() {
      //console.log(players); 
      Object.values(players).forEach (player=>{
        // if the player has no phaser group object, create one
        if (player.stuff.phaser_group == null) {
          player.stuff.phaser_group = player_group.create(resolution_width/2,resolution_height/2, 'spacepod');
        }
        //console.log(player);
      });
    }

    (async function() {

      const client = new StompJs.Client({
        brokerURL: 'ws://10.88.0.12:61613',
        connectHeaders: {
          login: 'user',
          passcode: 'password',
        },
        debug: function (str) {
          //console.log(str);
        },
        reconnectDelay: 5000,
        heartbeatIncoming: 4000,
        heartbeatOutgoing: 4000,
      });
  
      client.onConnect = function (frame) {
        // Do something, all subscribes must be done is this callback
        // This is needed because this will be executed after a (re)connect
      };
  
      client.onStompError = function (frame) {
        // Will be invoked in case of error encountered at Broker
        // Bad login/passcode typically will cause an error
        // Complaint brokers will set `message` header with a brief message. Body may contain details.
        // Compliant brokers will terminate the connection after any error
        console.log('Broker reported error: ' + frame.headers['message']);
        console.log('Additional details: ' + frame.body);
      };
  
      client.activate();

      try {
          const loadCommandBuffer = await protobuf.load("../proto/CommandBuffer.proto");
          const CommandBuffer = loadCommandBuffer.lookupType("redhatgamedev.srt.CommandBuffer");

          const loadSecurityCommandBuffer = await protobuf.load("../proto/SecurityCommandBuffer.proto");
          const SecurityCommandBuffer = loadSecurityCommandBuffer.lookupType("redhatgamedev.srt.SecurityCommandBuffer");

          const loadGameEventBuffer = await protobuf.load("../proto/GameEventBuffer.proto");
          const GameEventBuffer = loadGameEventBuffer.lookupType("redhatgamedev.srt.GameEventBuffer");

          const loadEntityGameEventBuffer = await protobuf.load("../proto/EntityGameEventBuffer.proto");
          const EntityGameEventBuffer = loadEntityGameEventBuffer.lookupType("redhatgamedev.srt.EntityGameEventBuffer");

          //console.log('loaded', {CommandBuffer, EntityGameEventBuffer});

          const scb_join = {type: 1, securityCommandBuffer: {type: 1}};
          const scb_join_message = CommandBuffer.create(scb_join); 
          const scb_join_buffer = CommandBuffer.encode(scb_join_message).finish();
          // setting content-type header is not mandatory, however a good practice
          client.publish({
              destination: '/queue/COMMAND.IN',
              binaryBody: scb_join_buffer,
              headers: { 
                  'content-type': 'application/octet-stream',
                  'reply-to': '/queue/COMMAND.OUT.' + myuuid
              },
          });

          process_security_game_event = function (buffer) {
            switch(buffer.type) {
              case 1:
                console.log('a player joined: ' + buffer.joinSecurityGameEventBuffer.UUID);
                // a security game event with a type of 1 is a player join
                // create an entity in the player array with the incoming uuid
                players[buffer.joinSecurityGameEventBuffer.UUID] = { body: "", stuff: "" }
                break;
            }
          };

          process_entity_game_event = function (buffer) {
            // just store the pbbody details for the player
            players[buffer.UUID].body = buffer.body;
          };

          // the function when game event messages are received
          game_event_message_callback = function (message) {
            // called when the client receives a STOMP message from the server
            if (message.binaryBody) {
              // we always receive a gameevent
              const decoded_event_message = GameEventBuffer.decode(message.binaryBody);
              console.log(decoded_event_message);

              // check on what type of game event we received
              switch(decoded_event_message.type) {
                case 2:
                  console.log('got a security event');
                  // security message
                  process_security_game_event(decoded_event_message.securityGameEventBuffer);
                  break;
                case 1:
                  // entity game event buffer is about a specific player
                  process_entity_game_event(decoded_event_message.entityGameEventBuffer);
                  break;
              }
            } else {
              console.log('for some reason we got a message with no binary boddy');
            }
          };

          // subscribe to the GAME.EVENT.OUT queue
          var game_event_subscription = client.subscribe('/topic/GAME.EVENT.OUT', game_event_message_callback);

          } catch (e) {
              console.error('Error during client initialization');
              throw e;
              /* handle error */
          }

      }
      
    ());
  </script>

</body>
</html>
